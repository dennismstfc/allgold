{"ast":null,"code":"/*!\n* chartjs-plugin-zoom v1.0.1\n* undefined\n * (c) 2016-2021 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, callback, sign } from 'chart.js/helpers';\n/**\n * @param {string|function} mode can be 'x', 'y' or 'xy'\n * @param {string} dir can be 'x' or 'y'\n * @param {import('chart.js').Chart} chart instance of the chart in question\n * @returns {boolean}\n */\n\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({\n      chart\n    }).indexOf(dir) !== -1;\n  }\n\n  return false;\n}\n/**\n * Debounces calling `fn` for `delay` ms\n * @param {function} fn - Function to call. No arguments are passed.\n * @param {number} delay - Delay in ms. 0 = immediate invocation.\n * @returns {function}\n */\n\n\nfunction debounce(fn, delay) {\n  let timeout;\n  return function () {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\n/** This function use for check what axis now under mouse cursor.\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale}\n */\n\n\nfunction getScaleUnderPoint({\n  x,\n  y\n}, chart) {\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n\n  return null;\n}\n/** This function return only one scale whose position is under mouse cursor and which direction is enabled.\n * If under mouse hasn't scale, then return all other scales which 'mode' is diffrent with overScaleMode.\n * So 'overScaleMode' works as a limiter to scale the user-selected scale (in 'mode') only when the cursor is under the scale,\n * and other directions in 'mode' works as before.\n * Example: mode = 'xy', overScaleMode = 'y' -> it's means 'x' - works as before, and 'y' only works for one scale when cursor is under it.\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\n * @param {string} mode - 'xy', 'x' or 'y'\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale[]}\n */\n\n\nfunction getEnabledScalesByPoint(mode, point, chart) {\n  const scale = getScaleUnderPoint(point, chart);\n\n  if (scale && directionEnabled(mode, scale.axis, chart)) {\n    return [scale];\n  }\n\n  const enabledScales = [];\n  each(chart.scales, function (scaleItem) {\n    if (!directionEnabled(mode, scaleItem.axis, chart)) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\n\nfunction zoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n  const centerPoint = scale.isHorizontal() ? center.x : center.y;\n  const minPercent = (scale.getValueForPixel(centerPoint) - scale.min) / range || 0;\n  const maxPercent = 1 - minPercent;\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\n\nfunction updateRange(scale, {\n  min,\n  max\n}, limits, zoom = false) {\n  const {\n    axis,\n    options: scaleOpts\n  } = scale;\n  const {\n    min: minLimit = -Infinity,\n    max: maxLimit = Infinity,\n    minRange = 0\n  } = limits && limits[axis] || {};\n  const cmin = Math.max(min, minLimit);\n  const cmax = Math.min(max, maxLimit);\n  const range = zoom ? Math.max(cmax - cmin, minRange) : scale.max - scale.min;\n\n  if (cmax - cmin !== range) {\n    if (minLimit > cmax - range) {\n      min = cmin;\n      max = cmin + range;\n    } else if (maxLimit < cmin + range) {\n      max = cmax;\n      min = cmax - range;\n    } else {\n      const offset = (range - cmax + cmin) / 2;\n      min = cmin - offset;\n      max = cmax + offset;\n    }\n  } else {\n    min = cmin;\n    max = cmax;\n  }\n\n  scaleOpts.min = min;\n  scaleOpts.max = max; // return true if the scale range is changed\n\n  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;\n}\n\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  const newRange = {\n    min: scale.min + delta.min,\n    max: scale.max - delta.max\n  };\n  return updateRange(scale, newRange, limits, true);\n}\n\nconst integerChange = v => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\n\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\n\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n\n  const newRange = {\n    min: scale.min + integerChange(delta.min),\n    max: scale.max - integerChange(delta.max)\n  };\n  return updateRange(scale, newRange, limits, true);\n}\n\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\n\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {\n    min,\n    max\n  } = scale; // The visible range. Ticks can be skipped, and thus not reliable.\n\n  const range = Math.max(max - min, 1); // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\n\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n\n  return updateRange(scale, {\n    min,\n    max\n  }, limits) || applied;\n}\n\nconst OFFSETS = {\n  second: 500,\n  // 500 ms\n  minute: 30 * 1000,\n  // 30 s\n  hour: 30 * 60 * 1000,\n  // 30 m\n  day: 12 * 60 * 60 * 1000,\n  // 12 h\n  week: 3.5 * 24 * 60 * 60 * 1000,\n  // 3.5 d\n  month: 15 * 24 * 60 * 60 * 1000,\n  // 15 d\n  quarter: 60 * 24 * 60 * 60 * 1000,\n  // 60 d\n  year: 182 * 24 * 60 * 60 * 1000 // 182 d\n\n};\n\nfunction panNumericalScale(scale, delta, limits, canZoom = false) {\n  const {\n    min: prevStart,\n    max: prevEnd,\n    options\n  } = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  const {\n    min: minLimit = -Infinity,\n    max: maxLimit = Infinity\n  } = canZoom && limits && limits[scale.axis] || {};\n\n  if (newMin < minLimit || newMax > maxLimit) {\n    return true; // At limit: No change but return true to indicate no need to store the delta.\n  }\n\n  return updateRange(scale, {\n    min: newMin,\n    max: newMax\n  }, limits, canZoom);\n}\n\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\n\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale\n};\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale\n};\nconst chartStates = new WeakMap();\n\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      handlers: {},\n      panDelta: {}\n    };\n    chartStates.set(chart, state);\n  }\n\n  return state;\n}\n\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction storeOriginalScaleLimits(chart) {\n  const {\n    originalScaleLimits\n  } = getState(chart);\n  each(chart.scales, function (scale) {\n    if (!originalScaleLimits[scale.id]) {\n      originalScaleLimits[scale.id] = {\n        min: scale.options.min,\n        max: scale.options.max\n      };\n    }\n  });\n  each(originalScaleLimits, function (opt, key) {\n    if (!chart.scales[key]) {\n      delete originalScaleLimits[key];\n    }\n  });\n  return originalScaleLimits;\n}\n\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\n\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2\n  };\n}\n/**\n * @param chart The chart instance\n * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point\n * @param {string} [transition] Which transiton mode to use. Defaults to 'none'\n */\n\n\nfunction zoom(chart, amount, transition = 'none') {\n  const {\n    x = 1,\n    y = 1,\n    focalPoint = getCenter(chart)\n  } = typeof amount === 'number' ? {\n    x: amount,\n    y: amount\n  } : amount;\n  const {\n    options: {\n      limits,\n      zoom: zoomOptions\n    }\n  } = getState(chart);\n  const {\n    mode = 'xy',\n    overScaleMode\n  } = zoomOptions || {};\n  storeOriginalScaleLimits(chart);\n  const xEnabled = x !== 1 && directionEnabled(mode, 'x', chart);\n  const yEnabled = y !== 1 && directionEnabled(mode, 'y', chart);\n  const enabledScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, focalPoint, chart);\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart\n  }]);\n}\n\nfunction getRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\n\nfunction zoomRect(chart, p0, p1, transition = 'none') {\n  const {\n    options: {\n      limits,\n      zoom: zoomOptions\n    }\n  } = getState(chart);\n  const {\n    mode = 'xy'\n  } = zoomOptions;\n  storeOriginalScaleLimits(chart);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  each(chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      updateRange(scale, getRange(scale, p0.x, p1.x), limits, true);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      updateRange(scale, getRange(scale, p0.y, p1.y), limits, true);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart\n  }]);\n}\n\nfunction zoomScale(chart, scaleId, range, transition = 'none') {\n  storeOriginalScaleLimits(chart);\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n}\n\nfunction resetZoom(chart, transition = 'default') {\n  const originalScaleLimits = storeOriginalScaleLimits(chart);\n  each(chart.scales, function (scale) {\n    const scaleOptions = scale.options;\n\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min;\n      scaleOptions.max = originalScaleLimits[scale.id].max;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n  });\n  chart.update(transition);\n}\n\nfunction panScale(scale, delta, limits) {\n  const {\n    panDelta\n  } = getState(scale.chart); // Add possible cumulative delta from previous pan attempts where scale did not change\n\n  const storedDelta = panDelta[scale.id] || 0;\n\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n\n  const fn = panFunctions[scale.type] || panFunctions.default;\n\n  if (callback(fn, [scale, delta, limits])) {\n    // The scale changed, reset cumulative delta\n    panDelta[scale.id] = 0;\n  } else {\n    // The scale did not change, store cumulative delta\n    panDelta[scale.id] = delta;\n  }\n}\n\nfunction pan(chart, delta, enabledScales, transition = 'none') {\n  const {\n    x = 0,\n    y = 0\n  } = typeof delta === 'number' ? {\n    x: delta,\n    y: delta\n  } : delta;\n  const {\n    options: {\n      pan: panOptions,\n      limits\n    }\n  } = getState(chart);\n  const {\n    mode = 'xy',\n    onPan\n  } = panOptions || {};\n  storeOriginalScaleLimits(chart);\n  const xEnabled = x !== 0 && directionEnabled(mode, 'x', chart);\n  const yEnabled = y !== 0 && directionEnabled(mode, 'y', chart);\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits);\n    }\n  });\n  chart.update(transition);\n  callback(onPan, [{\n    chart\n  }]);\n}\n\nfunction removeHandler(chart, target, type) {\n  const {\n    handlers\n  } = getState(chart);\n  const handler = handlers[type];\n\n  if (handler) {\n    target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\n\nfunction addHandler(chart, target, type, handler) {\n  const {\n    handlers,\n    options\n  } = getState(chart);\n  removeHandler(chart, target, type);\n\n  handlers[type] = event => handler(chart, event, options);\n\n  target.addEventListener(type, handlers[type]);\n}\n\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\n\nfunction zoomStart(chart, event, zoomOptions) {\n  const {\n    onZoomStart,\n    onZoomRejected\n  } = zoomOptions;\n\n  if (onZoomStart) {\n    const {\n      left: offsetX,\n      top: offsetY\n    } = event.target.getBoundingClientRect();\n    const point = {\n      x: event.clientX - offsetX,\n      y: event.clientY - offsetY\n    };\n\n    if (callback(onZoomStart, [{\n      chart,\n      event,\n      point\n    }]) === false) {\n      callback(onZoomRejected, [{\n        chart,\n        event\n      }]);\n      return false;\n    }\n  }\n}\n\nfunction mouseDown(chart, event) {\n  const state = getState(chart);\n  const {\n    pan: panOptions,\n    zoom: zoomOptions\n  } = state.options;\n  const panKey = panOptions && panOptions.modifierKey;\n\n  if (panKey && event[panKey + 'Key']) {\n    return callback(zoomOptions.onZoomRejected, [{\n      chart,\n      event\n    }]);\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n\n  state.dragStart = event;\n  addHandler(chart, chart.canvas, 'mousemove', mouseMove);\n}\n\nfunction computeDragRect(chart, mode, beginPoint, endPoint) {\n  const {\n    left: offsetX,\n    top: offsetY\n  } = beginPoint.target.getBoundingClientRect();\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  let {\n    top,\n    left,\n    right,\n    bottom,\n    width: chartWidth,\n    height: chartHeight\n  } = chart.chartArea;\n\n  if (xEnabled) {\n    left = Math.min(beginPoint.clientX, endPoint.clientX) - offsetX;\n    right = Math.max(beginPoint.clientX, endPoint.clientX) - offsetX;\n  }\n\n  if (yEnabled) {\n    top = Math.min(beginPoint.clientY, endPoint.clientY) - offsetY;\n    bottom = Math.max(beginPoint.clientY, endPoint.clientY) - offsetY;\n  }\n\n  const width = right - left;\n  const height = bottom - top;\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + (chartWidth - width) / chartWidth : 1,\n    zoomY: yEnabled && height ? 1 + (chartHeight - height) / chartHeight : 1\n  };\n}\n\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n\n  if (!state.dragStart) {\n    return;\n  }\n\n  removeHandler(chart.canvas, 'mousemove', chart);\n  const {\n    mode,\n    onZoomComplete,\n    drag: {\n      threshold = 0\n    }\n  } = state.options.zoom;\n  const rect = computeDragRect(chart, mode, state.dragStart, event);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY); // Remove drag start and end before chart update to stop drawing selected area\n\n  state.dragStart = state.dragEnd = null;\n\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n\n  zoomRect(chart, {\n    x: rect.left,\n    y: rect.top\n  }, {\n    x: rect.right,\n    y: rect.bottom\n  }, 'zoom');\n  setTimeout(() => state.dragging = false, 500);\n  callback(onZoomComplete, [{\n    chart\n  }]);\n}\n\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  const {\n    wheel: wheelOptions,\n    onZoomRejected\n  } = zoomOptions; // Before preventDefault, check if the modifier key required and pressed\n\n  if (wheelOptions.modifierKey && !event[wheelOptions.modifierKey + 'Key']) {\n    callback(onZoomRejected, [{\n      chart,\n      event\n    }]);\n    return;\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  } // Prevent the event from triggering the default behavior (eg. Content scrolling).\n\n\n  if (event.cancelable) {\n    event.preventDefault();\n  } // Firefox always fires the wheel event twice:\n  // First without the delta and right after that once with the delta properties.\n\n\n  if (event.deltaY === undefined) {\n    return;\n  }\n\n  return true;\n}\n\nfunction wheel(chart, event) {\n  const {\n    handlers: {\n      onZoomComplete\n    },\n    options: {\n      zoom: zoomOptions\n    }\n  } = getState(chart);\n\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n\n  const rect = event.target.getBoundingClientRect();\n  const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);\n  const amount = {\n    x: speed,\n    y: speed,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n  zoom(chart, amount);\n\n  if (onZoomComplete) {\n    onZoomComplete();\n  }\n}\n\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{\n      chart\n    }]), delay);\n  }\n}\n\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {\n    wheel: wheelOptions,\n    drag: dragOptions,\n    onZoomComplete\n  } = options.zoom; // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\n\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, canvas, 'wheel');\n  }\n\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, canvas, 'mousedown');\n    removeHandler(chart, canvas, 'mousemove');\n    removeHandler(chart, canvas.ownerDocument, 'mouseup');\n  }\n}\n\nfunction removeListeners(chart) {\n  const {\n    canvas\n  } = chart;\n\n  if (!canvas) {\n    return;\n  }\n\n  removeHandler(chart, canvas, 'mousedown');\n  removeHandler(chart, canvas, 'mousemove');\n  removeHandler(chart, canvas.ownerDocument, 'mouseup');\n  removeHandler(chart, canvas, 'wheel');\n  removeHandler(chart, canvas, 'click');\n}\n\nfunction createEnabler(chart) {\n  const state = getState(chart);\n  return function (recognizer, event) {\n    const panOptions = state.options.pan;\n\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n\n    if (!event || !event.srcEvent) {\n      // Sometimes Hammer queries this with a null event.\n      return true;\n    }\n\n    const modifierKey = panOptions.modifierKey;\n    const requireModifier = modifierKey && event.pointerType === 'mouse';\n\n    if (!state.panning && requireModifier && !event.srcEvent[modifierKey + 'Key']) {\n      callback(panOptions.onPanRejected, [{\n        chart,\n        event\n      }]);\n      return false;\n    }\n\n    return true;\n  };\n}\n\nfunction pinchAxes(p0, p1) {\n  // fingers position difference\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY); // diagonal fingers will change both (xy) axes\n\n  const p = pinchX / pinchY;\n  let x, y;\n\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n\n  return {\n    x,\n    y\n  };\n}\n\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {\n      center,\n      pointers\n    } = e; // Hammer reports the total scaling. We need the incremental amount\n\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n    zoom(chart, amount); // Keep track of overall scale\n\n    state.scale = e.scale;\n  }\n}\n\nfunction startPinch(chart, state) {\n  if (state.options.zoom.pinch.enabled) {\n    state.scale = 1;\n  }\n}\n\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null; // reset\n\n    callback(state.options.zoom.onZoomComplete, [{\n      chart\n    }]);\n  }\n}\n\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n\n  if (delta) {\n    state.panning = true;\n    pan(chart, {\n      x: e.deltaX - delta.x,\n      y: e.deltaY - delta.y\n    }, state.panScales);\n    state.delta = {\n      x: e.deltaX,\n      y: e.deltaY\n    };\n  }\n}\n\nfunction startPan(chart, state, event) {\n  const {\n    enabled,\n    overScaleMode,\n    onPanStart,\n    onPanRejected\n  } = state.options.pan;\n\n  if (!enabled) {\n    return;\n  }\n\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n\n  if (callback(onPanStart, [{\n    chart,\n    event,\n    point\n  }]) === false) {\n    return callback(onPanRejected, [{\n      chart,\n      event\n    }]);\n  }\n\n  state.panScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, point, chart);\n  state.delta = {\n    x: 0,\n    y: 0\n  };\n  clearTimeout(state.panEndTimeout);\n  handlePan(chart, state, event);\n}\n\nfunction endPan(chart, state) {\n  state.delta = null;\n\n  if (state.panning) {\n    state.panEndTimeout = setTimeout(() => state.panning = false, 500);\n    callback(state.options.pan.onPanComplete, [{\n      chart\n    }]);\n  }\n}\n\nconst hammers = new WeakMap();\n\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {\n    pan: panOptions,\n    zoom: zoomOptions\n  } = options;\n  const mc = new Hammer.Manager(canvas);\n\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', () => startPinch(chart, state));\n    mc.on('pinch', e => handlePinch(chart, state, e));\n    mc.on('pinchend', e => endPinch(chart, state, e));\n  }\n\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart)\n    }));\n    mc.on('panstart', e => startPan(chart, state, e));\n    mc.on('panmove', e => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n\n  hammers.set(chart, mc);\n}\n\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\n\nvar version = \"1.0.1\";\nvar plugin = {\n  id: 'zoom',\n  version,\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy'\n    }\n  },\n  start: function (chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n\n    chart.resetZoom = transition => resetZoom(chart, transition);\n  },\n\n  beforeEvent(chart) {\n    const state = getState(chart);\n\n    if (state.panning || state.dragging) {\n      // cancel any event handling while panning or dragging\n      return false;\n    }\n  },\n\n  beforeUpdate: function (chart, args, options) {\n    const state = getState(chart);\n    state.options = options;\n    addListeners(chart, options);\n  },\n  beforeDatasetsDraw: function (chart, args, options) {\n    const {\n      dragStart,\n      dragEnd\n    } = getState(chart);\n\n    if (dragEnd) {\n      const {\n        left,\n        top,\n        width,\n        height\n      } = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);\n      const dragOptions = options.zoom.drag;\n      const ctx = chart.ctx;\n      ctx.save();\n      ctx.beginPath();\n      ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n      ctx.fillRect(left, top, width, height);\n\n      if (dragOptions.borderWidth > 0) {\n        ctx.lineWidth = dragOptions.borderWidth;\n        ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n        ctx.strokeRect(left, top, width, height);\n      }\n\n      ctx.restore();\n    }\n  },\n  stop: function (chart) {\n    removeListeners(chart);\n\n    if (Hammer) {\n      stopHammer(chart);\n    }\n\n    removeState(chart);\n  },\n  panFunctions,\n  zoomFunctions\n};\nexport default plugin;\nexport { pan, resetZoom, zoom, zoomScale };","map":{"version":3,"sources":["C:/Users/denni/Documents/GitHub/allgold-website/frontend/node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js"],"names":["Hammer","each","callback","sign","directionEnabled","mode","dir","chart","undefined","indexOf","debounce","fn","delay","timeout","clearTimeout","setTimeout","getScaleUnderPoint","x","y","scales","scaleIds","Object","keys","i","length","scale","top","bottom","left","right","getEnabledScalesByPoint","point","axis","enabledScales","scaleItem","push","zoomDelta","zoom","center","range","max","min","newRange","centerPoint","isHorizontal","minPercent","getValueForPixel","maxPercent","updateRange","limits","options","scaleOpts","minLimit","Infinity","maxLimit","minRange","cmin","Math","cmax","offset","parse","zoomNumericalScale","delta","integerChange","v","isNaN","round","existCategoryFromMaxZoom","labels","getLabels","maxIndex","zoomCategoryScale","scaleLength","width","height","panCategoryScale","lastLabelIndex","stepDelta","stepSize","abs","applied","OFFSETS","second","minute","hour","day","week","month","quarter","year","panNumericalScale","canZoom","prevStart","prevEnd","time","newMin","getPixelForValue","newMax","panNonLinearScale","zoomFunctions","category","default","panFunctions","logarithmic","timeseries","chartStates","WeakMap","getState","state","get","originalScaleLimits","handlers","panDelta","set","removeState","delete","storeOriginalScaleLimits","id","opt","key","doZoom","amount","type","getCenter","ca","chartArea","transition","focalPoint","zoomOptions","overScaleMode","xEnabled","yEnabled","update","onZoom","getRange","pixel0","pixel1","v0","v1","zoomRect","p0","p1","zoomScale","scaleId","resetZoom","scaleOptions","panScale","storedDelta","pan","panOptions","onPan","removeHandler","target","handler","removeEventListener","addHandler","event","addEventListener","mouseMove","dragStart","dragging","dragEnd","zoomStart","onZoomStart","onZoomRejected","offsetX","offsetY","getBoundingClientRect","clientX","clientY","mouseDown","panKey","modifierKey","canvas","computeDragRect","beginPoint","endPoint","chartWidth","chartHeight","zoomX","zoomY","mouseUp","onZoomComplete","drag","threshold","rect","distanceX","distanceY","distance","sqrt","wheelPreconditions","wheel","wheelOptions","cancelable","preventDefault","deltaY","speed","addDebouncedHandler","name","addListeners","dragOptions","enabled","ownerDocument","removeListeners","createEnabler","recognizer","srcEvent","requireModifier","pointerType","panning","onPanRejected","pinchAxes","pinchX","pinchY","p","handlePinch","e","pointers","zoomPercent","pinch","startPinch","endPinch","handlePan","deltaX","panScales","startPan","onPanStart","panEndTimeout","endPan","onPanComplete","hammers","startHammer","mc","Manager","add","Pinch","on","Pan","enable","stopHammer","remove","destroy","version","plugin","defaults","start","_args","prototype","hasOwnProperty","call","console","warn","args","beforeEvent","beforeUpdate","beforeDatasetsDraw","ctx","save","beginPath","fillStyle","backgroundColor","fillRect","borderWidth","lineWidth","strokeStyle","borderColor","strokeRect","restore","stop"],"mappings":"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","sourcesContent":["/*!\n* chartjs-plugin-zoom v1.0.1\n* undefined\n * (c) 2016-2021 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, callback, sign } from 'chart.js/helpers';\n\n/**\n * @param {string|function} mode can be 'x', 'y' or 'xy'\n * @param {string} dir can be 'x' or 'y'\n * @param {import('chart.js').Chart} chart instance of the chart in question\n * @returns {boolean}\n */\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({chart}).indexOf(dir) !== -1;\n  }\n\n  return false;\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n * @param {function} fn - Function to call. No arguments are passed.\n * @param {number} delay - Delay in ms. 0 = immediate invocation.\n * @returns {function}\n */\nfunction debounce(fn, delay) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\n\n/** This function use for check what axis now under mouse cursor.\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale}\n */\nfunction getScaleUnderPoint({x, y}, chart) {\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\n\n/** This function return only one scale whose position is under mouse cursor and which direction is enabled.\n * If under mouse hasn't scale, then return all other scales which 'mode' is diffrent with overScaleMode.\n * So 'overScaleMode' works as a limiter to scale the user-selected scale (in 'mode') only when the cursor is under the scale,\n * and other directions in 'mode' works as before.\n * Example: mode = 'xy', overScaleMode = 'y' -> it's means 'x' - works as before, and 'y' only works for one scale when cursor is under it.\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\n * @param {string} mode - 'xy', 'x' or 'y'\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale[]}\n */\nfunction getEnabledScalesByPoint(mode, point, chart) {\n  const scale = getScaleUnderPoint(point, chart);\n\n  if (scale && directionEnabled(mode, scale.axis, chart)) {\n    return [scale];\n  }\n\n  const enabledScales = [];\n  each(chart.scales, function(scaleItem) {\n    if (!directionEnabled(mode, scaleItem.axis, chart)) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\n\nfunction zoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n\n  const centerPoint = scale.isHorizontal() ? center.x : center.y;\n  const minPercent = (scale.getValueForPixel(centerPoint) - scale.min) / range || 0;\n  const maxPercent = 1 - minPercent;\n\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\n\nfunction updateRange(scale, {min, max}, limits, zoom = false) {\n  const {axis, options: scaleOpts} = scale;\n  const {min: minLimit = -Infinity, max: maxLimit = Infinity, minRange = 0} = limits && limits[axis] || {};\n  const cmin = Math.max(min, minLimit);\n  const cmax = Math.min(max, maxLimit);\n  const range = zoom ? Math.max(cmax - cmin, minRange) : scale.max - scale.min;\n  if (cmax - cmin !== range) {\n    if (minLimit > cmax - range) {\n      min = cmin;\n      max = cmin + range;\n    } else if (maxLimit < cmin + range) {\n      max = cmax;\n      min = cmax - range;\n    } else {\n      const offset = (range - cmax + cmin) / 2;\n      min = cmin - offset;\n      max = cmax + offset;\n    }\n  } else {\n    min = cmin;\n    max = cmax;\n  }\n  scaleOpts.min = min;\n  scaleOpts.max = max;\n  // return true if the scale range is changed\n  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;\n}\n\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  const newRange = {min: scale.min + delta.min, max: scale.max - delta.max};\n  return updateRange(scale, newRange, limits, true);\n}\n\nconst integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\n\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n\n}\n\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max)};\n  return updateRange(scale, newRange, limits, true);\n}\n\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\n\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {min, max} = scale;\n  // The visible range. Ticks can be skipped, and thus not reliable.\n  const range = Math.max(max - min, 1);\n  // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n\n  return updateRange(scale, {min, max}, limits) || applied;\n}\n\nconst OFFSETS = {\n  second: 500, // 500 ms\n  minute: 30 * 1000, // 30 s\n  hour: 30 * 60 * 1000, // 30 m\n  day: 12 * 60 * 60 * 1000, // 12 h\n  week: 3.5 * 24 * 60 * 60 * 1000, // 3.5 d\n  month: 15 * 24 * 60 * 60 * 1000, // 15 d\n  quarter: 60 * 24 * 60 * 60 * 1000, // 60 d\n  year: 182 * 24 * 60 * 60 * 1000 // 182 d\n};\n\nfunction panNumericalScale(scale, delta, limits, canZoom = false) {\n  const {min: prevStart, max: prevEnd, options} = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  const {min: minLimit = -Infinity, max: maxLimit = Infinity} = canZoom && limits && limits[scale.axis] || {};\n  if ((newMin < minLimit || newMax > maxLimit)) {\n    return true; // At limit: No change but return true to indicate no need to store the delta.\n  }\n  return updateRange(scale, {min: newMin, max: newMax}, limits, canZoom);\n}\n\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\n\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale,\n};\n\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale,\n};\n\nconst chartStates = new WeakMap();\n\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      handlers: {},\n      panDelta: {}\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\n\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction storeOriginalScaleLimits(chart) {\n  const {originalScaleLimits} = getState(chart);\n  each(chart.scales, function(scale) {\n    if (!originalScaleLimits[scale.id]) {\n      originalScaleLimits[scale.id] = {min: scale.options.min, max: scale.options.max};\n    }\n  });\n  each(originalScaleLimits, function(opt, key) {\n    if (!chart.scales[key]) {\n      delete originalScaleLimits[key];\n    }\n  });\n  return originalScaleLimits;\n}\n\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\n\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2,\n  };\n}\n\n/**\n * @param chart The chart instance\n * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point\n * @param {string} [transition] Which transiton mode to use. Defaults to 'none'\n */\nfunction zoom(chart, amount, transition = 'none') {\n  const {x = 1, y = 1, focalPoint = getCenter(chart)} = typeof amount === 'number' ? {x: amount, y: amount} : amount;\n  const {options: {limits, zoom: zoomOptions}} = getState(chart);\n  const {mode = 'xy', overScaleMode} = zoomOptions || {};\n\n  storeOriginalScaleLimits(chart);\n\n  const xEnabled = x !== 1 && directionEnabled(mode, 'x', chart);\n  const yEnabled = y !== 1 && directionEnabled(mode, 'y', chart);\n  const enabledScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, focalPoint, chart);\n\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(zoomOptions.onZoom, [{chart}]);\n}\n\nfunction getRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\n\nfunction zoomRect(chart, p0, p1, transition = 'none') {\n  const {options: {limits, zoom: zoomOptions}} = getState(chart);\n  const {mode = 'xy'} = zoomOptions;\n\n  storeOriginalScaleLimits(chart);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n\n  each(chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      updateRange(scale, getRange(scale, p0.x, p1.x), limits, true);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      updateRange(scale, getRange(scale, p0.y, p1.y), limits, true);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(zoomOptions.onZoom, [{chart}]);\n}\n\nfunction zoomScale(chart, scaleId, range, transition = 'none') {\n  storeOriginalScaleLimits(chart);\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n}\n\n\nfunction resetZoom(chart, transition = 'default') {\n  const originalScaleLimits = storeOriginalScaleLimits(chart);\n\n  each(chart.scales, function(scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min;\n      scaleOptions.max = originalScaleLimits[scale.id].max;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n  });\n  chart.update(transition);\n}\n\nfunction panScale(scale, delta, limits) {\n  const {panDelta} = getState(scale.chart);\n  // Add possible cumulative delta from previous pan attempts where scale did not change\n  const storedDelta = panDelta[scale.id] || 0;\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if (callback(fn, [scale, delta, limits])) {\n    // The scale changed, reset cumulative delta\n    panDelta[scale.id] = 0;\n  } else {\n    // The scale did not change, store cumulative delta\n    panDelta[scale.id] = delta;\n  }\n}\n\nfunction pan(chart, delta, enabledScales, transition = 'none') {\n  const {x = 0, y = 0} = typeof delta === 'number' ? {x: delta, y: delta} : delta;\n  const {options: {pan: panOptions, limits}} = getState(chart);\n  const {mode = 'xy', onPan} = panOptions || {};\n\n  storeOriginalScaleLimits(chart);\n\n  const xEnabled = x !== 0 && directionEnabled(mode, 'x', chart);\n  const yEnabled = y !== 0 && directionEnabled(mode, 'y', chart);\n\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(onPan, [{chart}]);\n}\n\nfunction removeHandler(chart, target, type) {\n  const {handlers} = getState(chart);\n  const handler = handlers[type];\n  if (handler) {\n    target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\n\nfunction addHandler(chart, target, type, handler) {\n  const {handlers, options} = getState(chart);\n  removeHandler(chart, target, type);\n  handlers[type] = (event) => handler(chart, event, options);\n  target.addEventListener(type, handlers[type]);\n}\n\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\n\nfunction zoomStart(chart, event, zoomOptions) {\n  const {onZoomStart, onZoomRejected} = zoomOptions;\n  if (onZoomStart) {\n    const {left: offsetX, top: offsetY} = event.target.getBoundingClientRect();\n    const point = {\n      x: event.clientX - offsetX,\n      y: event.clientY - offsetY\n    };\n    if (callback(onZoomStart, [{chart, event, point}]) === false) {\n      callback(onZoomRejected, [{chart, event}]);\n      return false;\n    }\n  }\n}\n\nfunction mouseDown(chart, event) {\n  const state = getState(chart);\n  const {pan: panOptions, zoom: zoomOptions} = state.options;\n  const panKey = panOptions && panOptions.modifierKey;\n  if (panKey && event[panKey + 'Key']) {\n    return callback(zoomOptions.onZoomRejected, [{chart, event}]);\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n\n  addHandler(chart, chart.canvas, 'mousemove', mouseMove);\n}\n\nfunction computeDragRect(chart, mode, beginPoint, endPoint) {\n  const {left: offsetX, top: offsetY} = beginPoint.target.getBoundingClientRect();\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  let {top, left, right, bottom, width: chartWidth, height: chartHeight} = chart.chartArea;\n\n  if (xEnabled) {\n    left = Math.min(beginPoint.clientX, endPoint.clientX) - offsetX;\n    right = Math.max(beginPoint.clientX, endPoint.clientX) - offsetX;\n  }\n\n  if (yEnabled) {\n    top = Math.min(beginPoint.clientY, endPoint.clientY) - offsetY;\n    bottom = Math.max(beginPoint.clientY, endPoint.clientY) - offsetY;\n  }\n  const width = right - left;\n  const height = bottom - top;\n\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + ((chartWidth - width) / chartWidth) : 1,\n    zoomY: yEnabled && height ? 1 + ((chartHeight - height) / chartHeight) : 1\n  };\n}\n\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n\n  removeHandler(chart.canvas, 'mousemove', chart);\n  const {mode, onZoomComplete, drag: {threshold = 0}} = state.options.zoom;\n  const rect = computeDragRect(chart, mode, state.dragStart, event);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n  // Remove drag start and end before chart update to stop drawing selected area\n  state.dragStart = state.dragEnd = null;\n\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n\n  zoomRect(chart, {x: rect.left, y: rect.top}, {x: rect.right, y: rect.bottom}, 'zoom');\n\n  setTimeout(() => (state.dragging = false), 500);\n  callback(onZoomComplete, [{chart}]);\n}\n\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  const {wheel: wheelOptions, onZoomRejected} = zoomOptions;\n  // Before preventDefault, check if the modifier key required and pressed\n  if (wheelOptions.modifierKey && !event[wheelOptions.modifierKey + 'Key']) {\n    callback(onZoomRejected, [{chart, event}]);\n    return;\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n\n  // Prevent the event from triggering the default behavior (eg. Content scrolling).\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n\n  // Firefox always fires the wheel event twice:\n  // First without the delta and right after that once with the delta properties.\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\n\nfunction wheel(chart, event) {\n  const {handlers: {onZoomComplete}, options: {zoom: zoomOptions}} = getState(chart);\n\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n\n  const rect = event.target.getBoundingClientRect();\n  const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);\n  const amount = {\n    x: speed,\n    y: speed,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n\n  zoom(chart, amount);\n\n  if (onZoomComplete) {\n    onZoomComplete();\n  }\n}\n\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{chart}]), delay);\n  }\n}\n\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {wheel: wheelOptions, drag: dragOptions, onZoomComplete} = options.zoom;\n\n  // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, canvas, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, canvas, 'mousedown');\n    removeHandler(chart, canvas, 'mousemove');\n    removeHandler(chart, canvas.ownerDocument, 'mouseup');\n  }\n}\n\nfunction removeListeners(chart) {\n  const {canvas} = chart;\n  if (!canvas) {\n    return;\n  }\n  removeHandler(chart, canvas, 'mousedown');\n  removeHandler(chart, canvas, 'mousemove');\n  removeHandler(chart, canvas.ownerDocument, 'mouseup');\n  removeHandler(chart, canvas, 'wheel');\n  removeHandler(chart, canvas, 'click');\n}\n\nfunction createEnabler(chart) {\n  const state = getState(chart);\n  return function(recognizer, event) {\n    const panOptions = state.options.pan;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    if (!event || !event.srcEvent) { // Sometimes Hammer queries this with a null event.\n      return true;\n    }\n    const modifierKey = panOptions.modifierKey;\n    const requireModifier = modifierKey && (event.pointerType === 'mouse');\n    if (!state.panning && requireModifier && !event.srcEvent[modifierKey + 'Key']) {\n      callback(panOptions.onPanRejected, [{chart, event}]);\n      return false;\n    }\n    return true;\n  };\n}\n\nfunction pinchAxes(p0, p1) {\n  // fingers position difference\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n\n  // diagonal fingers will change both (xy) axes\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {x, y};\n}\n\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {center, pointers} = e;\n    // Hammer reports the total scaling. We need the incremental amount\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n\n    zoom(chart, amount);\n\n    // Keep track of overall scale\n    state.scale = e.scale;\n  }\n}\n\nfunction startPinch(chart, state) {\n  if (state.options.zoom.pinch.enabled) {\n    state.scale = 1;\n  }\n}\n\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null; // reset\n    callback(state.options.zoom.onZoomComplete, [{chart}]);\n  }\n}\n\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {x: e.deltaX - delta.x, y: e.deltaY - delta.y}, state.panScales);\n    state.delta = {x: e.deltaX, y: e.deltaY};\n  }\n}\n\nfunction startPan(chart, state, event) {\n  const {enabled, overScaleMode, onPanStart, onPanRejected} = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n\n  if (callback(onPanStart, [{chart, event, point}]) === false) {\n    return callback(onPanRejected, [{chart, event}]);\n  }\n\n  state.panScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, point, chart);\n  state.delta = {x: 0, y: 0};\n  clearTimeout(state.panEndTimeout);\n  handlePan(chart, state, event);\n}\n\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panEndTimeout = setTimeout(() => (state.panning = false), 500);\n    callback(state.options.pan.onPanComplete, [{chart}]);\n  }\n}\n\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {pan: panOptions, zoom: zoomOptions} = options;\n\n  const mc = new Hammer.Manager(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', () => startPinch(chart, state));\n    mc.on('pinch', (e) => handlePinch(chart, state, e));\n    mc.on('pinchend', (e) => endPinch(chart, state, e));\n  }\n\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart)\n    }));\n    mc.on('panstart', (e) => startPan(chart, state, e));\n    mc.on('panmove', (e) => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n\n  hammers.set(chart, mc);\n}\n\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\n\nvar version = \"1.0.1\";\n\nvar plugin = {\n  id: 'zoom',\n\n  version,\n\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null,\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy',\n    }\n  },\n\n  start: function(chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = (transition) => resetZoom(chart, transition);\n  },\n\n  beforeEvent(chart) {\n    const state = getState(chart);\n    if (state.panning || state.dragging) {\n      // cancel any event handling while panning or dragging\n      return false;\n    }\n  },\n\n  beforeUpdate: function(chart, args, options) {\n    const state = getState(chart);\n    state.options = options;\n    addListeners(chart, options);\n  },\n\n  beforeDatasetsDraw: function(chart, args, options) {\n    const {dragStart, dragEnd} = getState(chart);\n\n    if (dragEnd) {\n      const {left, top, width, height} = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);\n\n      const dragOptions = options.zoom.drag;\n      const ctx = chart.ctx;\n\n      ctx.save();\n      ctx.beginPath();\n      ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n      ctx.fillRect(left, top, width, height);\n\n      if (dragOptions.borderWidth > 0) {\n        ctx.lineWidth = dragOptions.borderWidth;\n        ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n        ctx.strokeRect(left, top, width, height);\n      }\n      ctx.restore();\n    }\n  },\n\n  stop: function(chart) {\n    removeListeners(chart);\n\n    if (Hammer) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n\n  panFunctions,\n\n  zoomFunctions\n};\n\nexport default plugin;\nexport { pan, resetZoom, zoom, zoomScale };\n"]},"metadata":{},"sourceType":"module"}